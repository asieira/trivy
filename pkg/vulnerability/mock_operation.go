// Code generated by mockery v1.0.0. DO NOT EDIT.

package vulnerability

import mock "github.com/stretchr/testify/mock"
import pkgtypes "github.com/aquasecurity/trivy-db/pkg/types"
import types "github.com/aquasecurity/trivy/pkg/types"

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type FillInfoArgs struct {
	Vulns              []types.DetectedVulnerability
	VulnsAnything      bool
	ReportType         string
	ReportTypeAnything bool
}

type FillInfoExpectation struct {
	Args FillInfoArgs
}

func (_m *MockOperation) ApplyFillInfoExpectation(e FillInfoExpectation) {
	var args []interface{}
	if e.Args.VulnsAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulns)
	}
	if e.Args.ReportTypeAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.ReportType)
	}
	_m.On("FillInfo", args...)
}

func (_m *MockOperation) ApplyFillInfoExpectations(expectations []FillInfoExpectation) {
	for _, e := range expectations {
		_m.ApplyFillInfoExpectation(e)
	}
}

// FillInfo provides a mock function with given fields: vulns, reportType
func (_m *MockOperation) FillInfo(vulns []types.DetectedVulnerability, reportType string) {
	_m.Called(vulns, reportType)
}

type FilterArgs struct {
	Vulns                 []types.DetectedVulnerability
	VulnsAnything         bool
	Severities            []pkgtypes.Severity
	SeveritiesAnything    bool
	IgnoreUnfixed         bool
	IgnoreUnfixedAnything bool
	IgnoreFile            string
	IgnoreFileAnything    bool
}

type FilterReturns struct {
	_a0 []types.DetectedVulnerability
}

type FilterExpectation struct {
	Args    FilterArgs
	Returns FilterReturns
}

func (_m *MockOperation) ApplyFilterExpectation(e FilterExpectation) {
	var args []interface{}
	if e.Args.VulnsAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulns)
	}
	if e.Args.SeveritiesAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Severities)
	}
	if e.Args.IgnoreUnfixedAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.IgnoreUnfixed)
	}
	if e.Args.IgnoreFileAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.IgnoreFile)
	}
	_m.On("Filter", args...).Return(e.Returns._a0)
}

func (_m *MockOperation) ApplyFilterExpectations(expectations []FilterExpectation) {
	for _, e := range expectations {
		_m.ApplyFilterExpectation(e)
	}
}

// Filter provides a mock function with given fields: vulns, severities, ignoreUnfixed, ignoreFile
func (_m *MockOperation) Filter(vulns []types.DetectedVulnerability, severities []pkgtypes.Severity, ignoreUnfixed bool, ignoreFile string) []types.DetectedVulnerability {
	ret := _m.Called(vulns, severities, ignoreUnfixed, ignoreFile)

	var r0 []types.DetectedVulnerability
	if rf, ok := ret.Get(0).(func([]types.DetectedVulnerability, []pkgtypes.Severity, bool, string) []types.DetectedVulnerability); ok {
		r0 = rf(vulns, severities, ignoreUnfixed, ignoreFile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.DetectedVulnerability)
		}
	}

	return r0
}
